'''
8 间牢房排成一排，每间牢房不是有人住就是空着。
每天，无论牢房是被占用或空置，都会根据以下规则进行更改：
如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。
否则，它就会被空置。
（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）
我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。
根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。
示例 1：
输入：cells = [0,1,0,1,1,0,0,1], N = 7
输出：[0,0,1,1,0,0,0,0]
解释：
下表概述了监狱每天的状况：
Day 0: [0, 1, 0, 1, 1, 0, 0, 1]
Day 1: [0, 1, 1, 0, 0, 0, 0, 0]
Day 2: [0, 0, 0, 0, 1, 1, 1, 0]
Day 3: [0, 1, 1, 0, 0, 1, 0, 0]
Day 4: [0, 0, 0, 0, 0, 1, 0, 0]
Day 5: [0, 1, 1, 1, 0, 1, 0, 0]
Day 6: [0, 0, 1, 0, 1, 1, 0, 0]
Day 7: [0, 0, 1, 1, 0, 0, 0, 0]
示例 2：
输入：cells = [1,0,0,1,0,0,1,0], N = 1000000000
输出：[0,0,1,1,1,1,1,0]
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/prison-cells-after-n-days
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
'''

class Solution:
    def prisonAfterNDays(self, cells: List[int], n: int) -> List[int]:
        cell=[0]*8
        ls=[]
        for d in range(30): #先在一定范围内找到多少天为一个循环，否则如果n>100000000循环数会太多而超时
            for i in range(1,7):
                if cells[i-1]==1 and cells[i+1]==1:
                    cell[i]=1
                elif cells[i-1]==0 and cells[i+1]==0:
                    cell[i]=1
                else:
                    cell[i]=0
            cells=cell[:]
            ls.append(cells)
            if d>1 and cells==ls[0]:
                count=d
                break
        ls=ls[:-1] #ls最后一个元素为第一天的安排，所以要去掉
        return ls[n%count-1] #如果天数和循环数相同，余数为0，第-1个元素为第n天的安排

